/*
 * generated by Xtext 2.19.0
 */
package fr.inria.diverse.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class LogoGrammarAccess extends AbstractGrammarElementFinder {
	
	public class LogoProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.LogoProgram");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLogoProgramAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLogoProgramKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cInstructionsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cInstructionsInstructionParserRuleCall_3_0_0 = (RuleCall)cInstructionsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cSemicolonKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cInstructionsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cInstructionsInstructionParserRuleCall_3_1_1_0 = (RuleCall)cInstructionsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//LogoProgram ASM::LogoProgram:
		//	{ASM::LogoProgram}
		//	'LogoProgram'
		//	'{' (instructions+=Instruction (";" instructions+=Instruction)*)?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::LogoProgram} 'LogoProgram' '{' (instructions+=Instruction (";" instructions+=Instruction)*)? '}'
		public Group getGroup() { return cGroup; }
		
		//{ASM::LogoProgram}
		public Action getLogoProgramAction_0() { return cLogoProgramAction_0; }
		
		//'LogoProgram'
		public Keyword getLogoProgramKeyword_1() { return cLogoProgramKeyword_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2() { return cLeftCurlyBracketKeyword_2; }
		
		//(instructions+=Instruction (";" instructions+=Instruction)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//instructions+=Instruction
		public Assignment getInstructionsAssignment_3_0() { return cInstructionsAssignment_3_0; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_3_0_0() { return cInstructionsInstructionParserRuleCall_3_0_0; }
		
		//(";" instructions+=Instruction)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//";"
		public Keyword getSemicolonKeyword_3_1_0() { return cSemicolonKeyword_3_1_0; }
		
		//instructions+=Instruction
		public Assignment getInstructionsAssignment_3_1_1() { return cInstructionsAssignment_3_1_1; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_3_1_1_0() { return cInstructionsInstructionParserRuleCall_3_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class InstructionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Instruction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBackParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cForwardParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLeftParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRightParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPenDownParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cPenUpParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cClearParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cProcCallParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cProcDeclarationParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cBlockParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cIfParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		private final RuleCall cRepeatParserRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final RuleCall cWhileParserRuleCall_12 = (RuleCall)cAlternatives.eContents().get(12);
		
		//Instruction ASM::Instruction:
		//	Back | Forward | Left | Right | PenDown | PenUp | Clear | ProcCall | ProcDeclaration | Block | If | Repeat | While;
		@Override public ParserRule getRule() { return rule; }
		
		//Back | Forward | Left | Right | PenDown | PenUp | Clear | ProcCall | ProcDeclaration | Block | If | Repeat | While
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Back
		public RuleCall getBackParserRuleCall_0() { return cBackParserRuleCall_0; }
		
		//Forward
		public RuleCall getForwardParserRuleCall_1() { return cForwardParserRuleCall_1; }
		
		//Left
		public RuleCall getLeftParserRuleCall_2() { return cLeftParserRuleCall_2; }
		
		//Right
		public RuleCall getRightParserRuleCall_3() { return cRightParserRuleCall_3; }
		
		//PenDown
		public RuleCall getPenDownParserRuleCall_4() { return cPenDownParserRuleCall_4; }
		
		//PenUp
		public RuleCall getPenUpParserRuleCall_5() { return cPenUpParserRuleCall_5; }
		
		//Clear
		public RuleCall getClearParserRuleCall_6() { return cClearParserRuleCall_6; }
		
		//ProcCall
		public RuleCall getProcCallParserRuleCall_7() { return cProcCallParserRuleCall_7; }
		
		//ProcDeclaration
		public RuleCall getProcDeclarationParserRuleCall_8() { return cProcDeclarationParserRuleCall_8; }
		
		//Block
		public RuleCall getBlockParserRuleCall_9() { return cBlockParserRuleCall_9; }
		
		//If
		public RuleCall getIfParserRuleCall_10() { return cIfParserRuleCall_10; }
		
		//Repeat
		public RuleCall getRepeatParserRuleCall_11() { return cRepeatParserRuleCall_11; }
		
		//While
		public RuleCall getWhileParserRuleCall_12() { return cWhileParserRuleCall_12; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Expression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAddExpParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cEqualsLhsAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cRhsAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRhsExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRhsAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cGreaterLhsAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRhsExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRhsAssignment_1_1_2.eContents().get(0);
		private final Group cGroup_1_2 = (Group)cAlternatives_1.eContents().get(2);
		private final Keyword cLessThanSignKeyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final Action cLowerLhsAction_1_2_1 = (Action)cGroup_1_2.eContents().get(1);
		private final Assignment cRhsAssignment_1_2_2 = (Assignment)cGroup_1_2.eContents().get(2);
		private final RuleCall cRhsExpressionParserRuleCall_1_2_2_0 = (RuleCall)cRhsAssignment_1_2_2.eContents().get(0);
		
		//Expression ASM::Expression:
		//	AddExp (-> '==' {ASM::Equals.lhs=current} rhs=Expression | -> '>' {ASM::Greater.lhs=current} rhs=Expression | -> '<'
		//	{ASM::Lower.lhs=current} rhs=Expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//AddExp (-> '==' {ASM::Equals.lhs=current} rhs=Expression | -> '>' {ASM::Greater.lhs=current} rhs=Expression | -> '<'
		//{ASM::Lower.lhs=current} rhs=Expression)?
		public Group getGroup() { return cGroup; }
		
		//AddExp
		public RuleCall getAddExpParserRuleCall_0() { return cAddExpParserRuleCall_0; }
		
		//(-> '==' {ASM::Equals.lhs=current} rhs=Expression | -> '>' {ASM::Greater.lhs=current} rhs=Expression | -> '<'
		//{ASM::Lower.lhs=current} rhs=Expression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//-> '==' {ASM::Equals.lhs=current} rhs=Expression
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//-> '=='
		public Keyword getEqualsSignEqualsSignKeyword_1_0_0() { return cEqualsSignEqualsSignKeyword_1_0_0; }
		
		//{ASM::Equals.lhs=current}
		public Action getEqualsLhsAction_1_0_1() { return cEqualsLhsAction_1_0_1; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1_0_2() { return cRhsAssignment_1_0_2; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_0_2_0() { return cRhsExpressionParserRuleCall_1_0_2_0; }
		
		//-> '>' {ASM::Greater.lhs=current} rhs=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//-> '>'
		public Keyword getGreaterThanSignKeyword_1_1_0() { return cGreaterThanSignKeyword_1_1_0; }
		
		//{ASM::Greater.lhs=current}
		public Action getGreaterLhsAction_1_1_1() { return cGreaterLhsAction_1_1_1; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1_1_2() { return cRhsAssignment_1_1_2; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_1_2_0() { return cRhsExpressionParserRuleCall_1_1_2_0; }
		
		//-> '<' {ASM::Lower.lhs=current} rhs=Expression
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//-> '<'
		public Keyword getLessThanSignKeyword_1_2_0() { return cLessThanSignKeyword_1_2_0; }
		
		//{ASM::Lower.lhs=current}
		public Action getLowerLhsAction_1_2_1() { return cLowerLhsAction_1_2_1; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1_2_2() { return cRhsAssignment_1_2_2; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_2_2_0() { return cRhsExpressionParserRuleCall_1_2_2_0; }
	}
	public class AddExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.AddExp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cPlusLhsAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cRhsAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRhsExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRhsAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cMinusLhsAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRhsExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRhsAssignment_1_1_2.eContents().get(0);
		
		//AddExp ASM::Expression:
		//	MultExpr (-> '+' {ASM::Plus.lhs=current} rhs=Expression | -> '-' {ASM::Minus.lhs=current} rhs=Expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//MultExpr (-> '+' {ASM::Plus.lhs=current} rhs=Expression | -> '-' {ASM::Minus.lhs=current} rhs=Expression)?
		public Group getGroup() { return cGroup; }
		
		//MultExpr
		public RuleCall getMultExprParserRuleCall_0() { return cMultExprParserRuleCall_0; }
		
		//(-> '+' {ASM::Plus.lhs=current} rhs=Expression | -> '-' {ASM::Minus.lhs=current} rhs=Expression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//-> '+' {ASM::Plus.lhs=current} rhs=Expression
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//-> '+'
		public Keyword getPlusSignKeyword_1_0_0() { return cPlusSignKeyword_1_0_0; }
		
		//{ASM::Plus.lhs=current}
		public Action getPlusLhsAction_1_0_1() { return cPlusLhsAction_1_0_1; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1_0_2() { return cRhsAssignment_1_0_2; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_0_2_0() { return cRhsExpressionParserRuleCall_1_0_2_0; }
		
		//-> '-' {ASM::Minus.lhs=current} rhs=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//-> '-'
		public Keyword getHyphenMinusKeyword_1_1_0() { return cHyphenMinusKeyword_1_1_0; }
		
		//{ASM::Minus.lhs=current}
		public Action getMinusLhsAction_1_1_1() { return cMinusLhsAction_1_1_1; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1_1_2() { return cRhsAssignment_1_1_2; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_1_2_0() { return cRhsExpressionParserRuleCall_1_1_2_0; }
	}
	public class MultExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.MultExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final Action cMultLhsAction_1_0_1 = (Action)cGroup_1_0.eContents().get(1);
		private final Assignment cRhsAssignment_1_0_2 = (Assignment)cGroup_1_0.eContents().get(2);
		private final RuleCall cRhsExpressionParserRuleCall_1_0_2_0 = (RuleCall)cRhsAssignment_1_0_2.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cSolidusKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Action cDivLhsAction_1_1_1 = (Action)cGroup_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_1_2 = (Assignment)cGroup_1_1.eContents().get(2);
		private final RuleCall cRhsExpressionParserRuleCall_1_1_2_0 = (RuleCall)cRhsAssignment_1_1_2.eContents().get(0);
		
		//MultExpr ASM::Expression:
		//	UnaryExp (-> '*' {ASM::Mult.lhs=current} rhs=Expression | -> '/' {ASM::Div.lhs=current} rhs=Expression)?;
		@Override public ParserRule getRule() { return rule; }
		
		//UnaryExp (-> '*' {ASM::Mult.lhs=current} rhs=Expression | -> '/' {ASM::Div.lhs=current} rhs=Expression)?
		public Group getGroup() { return cGroup; }
		
		//UnaryExp
		public RuleCall getUnaryExpParserRuleCall_0() { return cUnaryExpParserRuleCall_0; }
		
		//(-> '*' {ASM::Mult.lhs=current} rhs=Expression | -> '/' {ASM::Div.lhs=current} rhs=Expression)?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//-> '*' {ASM::Mult.lhs=current} rhs=Expression
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//-> '*'
		public Keyword getAsteriskKeyword_1_0_0() { return cAsteriskKeyword_1_0_0; }
		
		//{ASM::Mult.lhs=current}
		public Action getMultLhsAction_1_0_1() { return cMultLhsAction_1_0_1; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1_0_2() { return cRhsAssignment_1_0_2; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_0_2_0() { return cRhsExpressionParserRuleCall_1_0_2_0; }
		
		//-> '/' {ASM::Div.lhs=current} rhs=Expression
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//-> '/'
		public Keyword getSolidusKeyword_1_1_0() { return cSolidusKeyword_1_1_0; }
		
		//{ASM::Div.lhs=current}
		public Action getDivLhsAction_1_1_1() { return cDivLhsAction_1_1_1; }
		
		//rhs=Expression
		public Assignment getRhsAssignment_1_1_2() { return cRhsAssignment_1_1_2; }
		
		//Expression
		public RuleCall getRhsExpressionParserRuleCall_1_1_2_0() { return cRhsExpressionParserRuleCall_1_1_2_0; }
	}
	public class UnaryExpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.UnaryExp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCosParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSinParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTanParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cProcCallParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cPrimaryParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//UnaryExp ASM::Expression:
		//	Cos | Sin | Tan | ProcCall | Primary;
		@Override public ParserRule getRule() { return rule; }
		
		//Cos | Sin | Tan | ProcCall | Primary
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Cos
		public RuleCall getCosParserRuleCall_0() { return cCosParserRuleCall_0; }
		
		//Sin
		public RuleCall getSinParserRuleCall_1() { return cSinParserRuleCall_1; }
		
		//Tan
		public RuleCall getTanParserRuleCall_2() { return cTanParserRuleCall_2; }
		
		//ProcCall
		public RuleCall getProcCallParserRuleCall_3() { return cProcCallParserRuleCall_3; }
		
		//Primary
		public RuleCall getPrimaryParserRuleCall_4() { return cPrimaryParserRuleCall_4; }
	}
	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cConstantParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cParameterCallParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Primary ASM::Expression:
		//	Constant | ParameterCall;
		@Override public ParserRule getRule() { return rule; }
		
		//Constant | ParameterCall
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Constant
		public RuleCall getConstantParserRuleCall_0() { return cConstantParserRuleCall_0; }
		
		//ParameterCall
		public RuleCall getParameterCallParserRuleCall_1() { return cParameterCallParserRuleCall_1; }
	}
	public class BackElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Back");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBackAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cBackKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStepsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStepsExpressionParserRuleCall_2_0 = (RuleCall)cStepsAssignment_2.eContents().get(0);
		
		//Back ASM::Back:
		//	{ASM::Back}
		//	'Back' steps=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Back} 'Back' steps=Expression
		public Group getGroup() { return cGroup; }
		
		//{ASM::Back}
		public Action getBackAction_0() { return cBackAction_0; }
		
		//'Back'
		public Keyword getBackKeyword_1() { return cBackKeyword_1; }
		
		//steps=Expression
		public Assignment getStepsAssignment_2() { return cStepsAssignment_2; }
		
		//Expression
		public RuleCall getStepsExpressionParserRuleCall_2_0() { return cStepsExpressionParserRuleCall_2_0; }
	}
	public class ForwardElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Forward");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cForwardAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cForwardKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStepsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStepsExpressionParserRuleCall_2_0 = (RuleCall)cStepsAssignment_2.eContents().get(0);
		
		//Forward ASM::Forward:
		//	{ASM::Forward}
		//	'Forward'
		//	steps=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Forward} 'Forward' steps=Expression
		public Group getGroup() { return cGroup; }
		
		//{ASM::Forward}
		public Action getForwardAction_0() { return cForwardAction_0; }
		
		//'Forward'
		public Keyword getForwardKeyword_1() { return cForwardKeyword_1; }
		
		//steps=Expression
		public Assignment getStepsAssignment_2() { return cStepsAssignment_2; }
		
		//Expression
		public RuleCall getStepsExpressionParserRuleCall_2_0() { return cStepsExpressionParserRuleCall_2_0; }
	}
	public class LeftElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Left");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLeftAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAngleAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAngleExpressionParserRuleCall_2_0 = (RuleCall)cAngleAssignment_2.eContents().get(0);
		
		//Left ASM::Left:
		//	{ASM::Left}
		//	'Left' angle=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Left} 'Left' angle=Expression
		public Group getGroup() { return cGroup; }
		
		//{ASM::Left}
		public Action getLeftAction_0() { return cLeftAction_0; }
		
		//'Left'
		public Keyword getLeftKeyword_1() { return cLeftKeyword_1; }
		
		//angle=Expression
		public Assignment getAngleAssignment_2() { return cAngleAssignment_2; }
		
		//Expression
		public RuleCall getAngleExpressionParserRuleCall_2_0() { return cAngleExpressionParserRuleCall_2_0; }
	}
	public class RightElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Right");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRightAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRightKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cAngleAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cAngleExpressionParserRuleCall_2_0 = (RuleCall)cAngleAssignment_2.eContents().get(0);
		
		//Right ASM::Right:
		//	{ASM::Right}
		//	'Right' angle=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Right} 'Right' angle=Expression
		public Group getGroup() { return cGroup; }
		
		//{ASM::Right}
		public Action getRightAction_0() { return cRightAction_0; }
		
		//'Right'
		public Keyword getRightKeyword_1() { return cRightKeyword_1; }
		
		//angle=Expression
		public Assignment getAngleAssignment_2() { return cAngleAssignment_2; }
		
		//Expression
		public RuleCall getAngleExpressionParserRuleCall_2_0() { return cAngleExpressionParserRuleCall_2_0; }
	}
	public class PenDownElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.PenDown");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPenDownAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPenDownKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//PenDown ASM::PenDown:
		//	{ASM::PenDown}
		//	'PenDown';
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::PenDown} 'PenDown'
		public Group getGroup() { return cGroup; }
		
		//{ASM::PenDown}
		public Action getPenDownAction_0() { return cPenDownAction_0; }
		
		//'PenDown'
		public Keyword getPenDownKeyword_1() { return cPenDownKeyword_1; }
	}
	public class PenUpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.PenUp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPenUpAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cPenUpKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//PenUp ASM::PenUp:
		//	{ASM::PenUp}
		//	'PenUp';
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::PenUp} 'PenUp'
		public Group getGroup() { return cGroup; }
		
		//{ASM::PenUp}
		public Action getPenUpAction_0() { return cPenUpAction_0; }
		
		//'PenUp'
		public Keyword getPenUpKeyword_1() { return cPenUpKeyword_1; }
	}
	public class ClearElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Clear");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cClearAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cClearKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Clear ASM::Clear:
		//	{ASM::Clear}
		//	'Clear';
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Clear} 'Clear'
		public Group getGroup() { return cGroup; }
		
		//{ASM::Clear}
		public Action getClearAction_0() { return cClearAction_0; }
		
		//'Clear'
		public Keyword getClearKeyword_1() { return cClearKeyword_1; }
	}
	public class ConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Constant");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConstantAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueEDoubleParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//Constant ASM::Constant:
		//	{ASM::Constant} value=EDouble;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Constant} value=EDouble
		public Group getGroup() { return cGroup; }
		
		//{ASM::Constant}
		public Action getConstantAction_0() { return cConstantAction_0; }
		
		//value=EDouble
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//EDouble
		public RuleCall getValueEDoubleParserRuleCall_1_0() { return cValueEDoubleParserRuleCall_1_0; }
	}
	public class ProcCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.ProcCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProcCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cDeclarationProcDeclarationCrossReference_1_0 = (CrossReference)cDeclarationAssignment_1.eContents().get(0);
		private final RuleCall cDeclarationProcDeclarationIDTerminalRuleCall_1_0_1 = (RuleCall)cDeclarationProcDeclarationCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cActualArgsAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cActualArgsExpressionParserRuleCall_3_0_0 = (RuleCall)cActualArgsAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cActualArgsAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cActualArgsExpressionParserRuleCall_3_1_1_0 = (RuleCall)cActualArgsAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//ProcCall ASM::ProcCall:
		//	{ASM::ProcCall} declaration=[ASM::ProcDeclaration] '(' (actualArgs+=Expression ("," actualArgs+=Expression)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::ProcCall} declaration=[ASM::ProcDeclaration] '(' (actualArgs+=Expression ("," actualArgs+=Expression)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//{ASM::ProcCall}
		public Action getProcCallAction_0() { return cProcCallAction_0; }
		
		//declaration=[ASM::ProcDeclaration]
		public Assignment getDeclarationAssignment_1() { return cDeclarationAssignment_1; }
		
		//[ASM::ProcDeclaration]
		public CrossReference getDeclarationProcDeclarationCrossReference_1_0() { return cDeclarationProcDeclarationCrossReference_1_0; }
		
		//ID
		public RuleCall getDeclarationProcDeclarationIDTerminalRuleCall_1_0_1() { return cDeclarationProcDeclarationIDTerminalRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(actualArgs+=Expression ("," actualArgs+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//actualArgs+=Expression
		public Assignment getActualArgsAssignment_3_0() { return cActualArgsAssignment_3_0; }
		
		//Expression
		public RuleCall getActualArgsExpressionParserRuleCall_3_0_0() { return cActualArgsExpressionParserRuleCall_3_0_0; }
		
		//("," actualArgs+=Expression)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//","
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//actualArgs+=Expression
		public Assignment getActualArgsAssignment_3_1_1() { return cActualArgsAssignment_3_1_1; }
		
		//Expression
		public RuleCall getActualArgsExpressionParserRuleCall_3_1_1_0() { return cActualArgsExpressionParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class ProcDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.ProcDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cProcDeclarationAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cProcKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cArgsAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final RuleCall cArgsParameterParserRuleCall_4_0_0 = (RuleCall)cArgsAssignment_4_0.eContents().get(0);
		private final Group cGroup_4_1 = (Group)cGroup_4.eContents().get(1);
		private final Keyword cCommaKeyword_4_1_0 = (Keyword)cGroup_4_1.eContents().get(0);
		private final Assignment cArgsAssignment_4_1_1 = (Assignment)cGroup_4_1.eContents().get(1);
		private final RuleCall cArgsParameterParserRuleCall_4_1_1_0 = (RuleCall)cArgsAssignment_4_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Assignment cInstructionsAssignment_7_0 = (Assignment)cGroup_7.eContents().get(0);
		private final RuleCall cInstructionsInstructionParserRuleCall_7_0_0 = (RuleCall)cInstructionsAssignment_7_0.eContents().get(0);
		private final Group cGroup_7_1 = (Group)cGroup_7.eContents().get(1);
		private final Keyword cSemicolonKeyword_7_1_0 = (Keyword)cGroup_7_1.eContents().get(0);
		private final Assignment cInstructionsAssignment_7_1_1 = (Assignment)cGroup_7_1.eContents().get(1);
		private final RuleCall cInstructionsInstructionParserRuleCall_7_1_1_0 = (RuleCall)cInstructionsAssignment_7_1_1.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cReturnKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cInstructionsAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cInstructionsExpressionParserRuleCall_8_1_0 = (RuleCall)cInstructionsAssignment_8_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		//ProcDeclaration ASM::ProcDeclaration:
		//	{ASM::ProcDeclaration}
		//	'Proc' name=ID '(' (args+=Parameter ("," args+=Parameter)*)? ')'
		//	'{' (instructions+=Instruction (";" instructions+=Instruction)*)? ('Return' instructions+=Expression)?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::ProcDeclaration} 'Proc' name=ID '(' (args+=Parameter ("," args+=Parameter)*)? ')' '{' (instructions+=Instruction
		//(";" instructions+=Instruction)*)? ('Return' instructions+=Expression)? '}'
		public Group getGroup() { return cGroup; }
		
		//{ASM::ProcDeclaration}
		public Action getProcDeclarationAction_0() { return cProcDeclarationAction_0; }
		
		//'Proc'
		public Keyword getProcKeyword_1() { return cProcKeyword_1; }
		
		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3() { return cLeftParenthesisKeyword_3; }
		
		//(args+=Parameter ("," args+=Parameter)*)?
		public Group getGroup_4() { return cGroup_4; }
		
		//args+=Parameter
		public Assignment getArgsAssignment_4_0() { return cArgsAssignment_4_0; }
		
		//Parameter
		public RuleCall getArgsParameterParserRuleCall_4_0_0() { return cArgsParameterParserRuleCall_4_0_0; }
		
		//("," args+=Parameter)*
		public Group getGroup_4_1() { return cGroup_4_1; }
		
		//","
		public Keyword getCommaKeyword_4_1_0() { return cCommaKeyword_4_1_0; }
		
		//args+=Parameter
		public Assignment getArgsAssignment_4_1_1() { return cArgsAssignment_4_1_1; }
		
		//Parameter
		public RuleCall getArgsParameterParserRuleCall_4_1_1_0() { return cArgsParameterParserRuleCall_4_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_6() { return cLeftCurlyBracketKeyword_6; }
		
		//(instructions+=Instruction (";" instructions+=Instruction)*)?
		public Group getGroup_7() { return cGroup_7; }
		
		//instructions+=Instruction
		public Assignment getInstructionsAssignment_7_0() { return cInstructionsAssignment_7_0; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_7_0_0() { return cInstructionsInstructionParserRuleCall_7_0_0; }
		
		//(";" instructions+=Instruction)*
		public Group getGroup_7_1() { return cGroup_7_1; }
		
		//";"
		public Keyword getSemicolonKeyword_7_1_0() { return cSemicolonKeyword_7_1_0; }
		
		//instructions+=Instruction
		public Assignment getInstructionsAssignment_7_1_1() { return cInstructionsAssignment_7_1_1; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_7_1_1_0() { return cInstructionsInstructionParserRuleCall_7_1_1_0; }
		
		//('Return' instructions+=Expression)?
		public Group getGroup_8() { return cGroup_8; }
		
		//'Return'
		public Keyword getReturnKeyword_8_0() { return cReturnKeyword_8_0; }
		
		//instructions+=Expression
		public Assignment getInstructionsAssignment_8_1() { return cInstructionsAssignment_8_1; }
		
		//Expression
		public RuleCall getInstructionsExpressionParserRuleCall_8_1_0() { return cInstructionsExpressionParserRuleCall_8_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_9() { return cRightCurlyBracketKeyword_9; }
	}
	public class BlockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Block");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cInstructionsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cInstructionsInstructionParserRuleCall_2_0_0 = (RuleCall)cInstructionsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cSemicolonKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cInstructionsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cInstructionsInstructionParserRuleCall_2_1_1_0 = (RuleCall)cInstructionsAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Block ASM::Block:
		//	{ASM::Block}
		//	'{' (instructions+=Instruction (";" instructions+=Instruction)*)?
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Block} '{' (instructions+=Instruction (";" instructions+=Instruction)*)? '}'
		public Group getGroup() { return cGroup; }
		
		//{ASM::Block}
		public Action getBlockAction_0() { return cBlockAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(instructions+=Instruction (";" instructions+=Instruction)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//instructions+=Instruction
		public Assignment getInstructionsAssignment_2_0() { return cInstructionsAssignment_2_0; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_2_0_0() { return cInstructionsInstructionParserRuleCall_2_0_0; }
		
		//(";" instructions+=Instruction)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//";"
		public Keyword getSemicolonKeyword_2_1_0() { return cSemicolonKeyword_2_1_0; }
		
		//instructions+=Instruction
		public Assignment getInstructionsAssignment_2_1_1() { return cInstructionsAssignment_2_1_1; }
		
		//Instruction
		public RuleCall getInstructionsInstructionParserRuleCall_2_1_1_0() { return cInstructionsInstructionParserRuleCall_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class IfElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.If");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cIfAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cIfKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Assignment cThenPartAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cThenPartBlockParserRuleCall_3_0 = (RuleCall)cThenPartAssignment_3.eContents().get(0);
		private final Assignment cElsePartAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cElsePartBlockParserRuleCall_4_0 = (RuleCall)cElsePartAssignment_4.eContents().get(0);
		
		//If ASM::If:
		//	{ASM::If}
		//	'If' condition=Expression
		//	thenPart=Block
		//	elsePart=Block?;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::If} 'If' condition=Expression thenPart=Block elsePart=Block?
		public Group getGroup() { return cGroup; }
		
		//{ASM::If}
		public Action getIfAction_0() { return cIfAction_0; }
		
		//'If'
		public Keyword getIfKeyword_1() { return cIfKeyword_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }
		
		//thenPart=Block
		public Assignment getThenPartAssignment_3() { return cThenPartAssignment_3; }
		
		//Block
		public RuleCall getThenPartBlockParserRuleCall_3_0() { return cThenPartBlockParserRuleCall_3_0; }
		
		//elsePart=Block?
		public Assignment getElsePartAssignment_4() { return cElsePartAssignment_4; }
		
		//Block
		public RuleCall getElsePartBlockParserRuleCall_4_0() { return cElsePartBlockParserRuleCall_4_0; }
	}
	public class RepeatElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Repeat");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRepeatAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cRepeatKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Assignment cBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBlockBlockParserRuleCall_3_0 = (RuleCall)cBlockAssignment_3.eContents().get(0);
		
		//Repeat ASM::Repeat:
		//	{ASM::Repeat}
		//	'Repeat' condition=Expression
		//	block=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Repeat} 'Repeat' condition=Expression block=Block
		public Group getGroup() { return cGroup; }
		
		//{ASM::Repeat}
		public Action getRepeatAction_0() { return cRepeatAction_0; }
		
		//'Repeat'
		public Keyword getRepeatKeyword_1() { return cRepeatKeyword_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }
		
		//block=Block
		public Assignment getBlockAssignment_3() { return cBlockAssignment_3; }
		
		//Block
		public RuleCall getBlockBlockParserRuleCall_3_0() { return cBlockBlockParserRuleCall_3_0; }
	}
	public class WhileElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.While");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cWhileAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cWhileKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cConditionExpressionParserRuleCall_2_0 = (RuleCall)cConditionAssignment_2.eContents().get(0);
		private final Assignment cBlockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBlockBlockParserRuleCall_3_0 = (RuleCall)cBlockAssignment_3.eContents().get(0);
		
		//While ASM::While:
		//	{ASM::While}
		//	'While' condition=Expression
		//	block=Block;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::While} 'While' condition=Expression block=Block
		public Group getGroup() { return cGroup; }
		
		//{ASM::While}
		public Action getWhileAction_0() { return cWhileAction_0; }
		
		//'While'
		public Keyword getWhileKeyword_1() { return cWhileKeyword_1; }
		
		//condition=Expression
		public Assignment getConditionAssignment_2() { return cConditionAssignment_2; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_2_0() { return cConditionExpressionParserRuleCall_2_0; }
		
		//block=Block
		public Assignment getBlockAssignment_3() { return cBlockAssignment_3; }
		
		//Block
		public RuleCall getBlockBlockParserRuleCall_3_0() { return cBlockBlockParserRuleCall_3_0; }
	}
	public class ParameterCallElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.ParameterCall");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterCallAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParameterAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cParameterParameterCrossReference_1_0 = (CrossReference)cParameterAssignment_1.eContents().get(0);
		private final RuleCall cParameterParameterIDTerminalRuleCall_1_0_1 = (RuleCall)cParameterParameterCrossReference_1_0.eContents().get(1);
		
		//ParameterCall ASM::ParameterCall:
		//	{ASM::ParameterCall} parameter=[ASM::Parameter];
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::ParameterCall} parameter=[ASM::Parameter]
		public Group getGroup() { return cGroup; }
		
		//{ASM::ParameterCall}
		public Action getParameterCallAction_0() { return cParameterCallAction_0; }
		
		//parameter=[ASM::Parameter]
		public Assignment getParameterAssignment_1() { return cParameterAssignment_1; }
		
		//[ASM::Parameter]
		public CrossReference getParameterParameterCrossReference_1_0() { return cParameterParameterCrossReference_1_0; }
		
		//ID
		public RuleCall getParameterParameterIDTerminalRuleCall_1_0_1() { return cParameterParameterIDTerminalRuleCall_1_0_1; }
	}
	public class CosElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Cos");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cCosAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cCosKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//Cos ASM::Cos:
		//	{ASM::Cos}
		//	'Cos' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Cos} 'Cos' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//{ASM::Cos}
		public Action getCosAction_0() { return cCosAction_0; }
		
		//'Cos'
		public Keyword getCosKeyword_1() { return cCosKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class SinElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Sin");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSinAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSinKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//Sin ASM::Sin:
		//	{ASM::Sin}
		//	'Sin' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Sin} 'Sin' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//{ASM::Sin}
		public Action getSinAction_0() { return cSinAction_0; }
		
		//'Sin'
		public Keyword getSinKeyword_1() { return cSinKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class TanElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Tan");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTanAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cTanKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//Tan ASM::Tan:
		//	{ASM::Tan}
		//	'Tan' expression=Expression;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Tan} 'Tan' expression=Expression
		public Group getGroup() { return cGroup; }
		
		//{ASM::Tan}
		public Action getTanAction_0() { return cTanAction_0; }
		
		//'Tan'
		public Keyword getTanKeyword_1() { return cTanKeyword_1; }
		
		//expression=Expression
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class EDoubleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.EDouble");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Alternatives cAlternatives_4_0 = (Alternatives)cGroup_4.eContents().get(0);
		private final Keyword cEKeyword_4_0_0 = (Keyword)cAlternatives_4_0.eContents().get(0);
		private final Keyword cEKeyword_4_0_1 = (Keyword)cAlternatives_4_0.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_4_2 = (RuleCall)cGroup_4.eContents().get(2);
		
		//EDouble ecore::EDouble:
		//	'-'? INT? '.' INT (('E' | 'e') '-'? INT)?;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? INT? '.' INT (('E' | 'e') '-'? INT)?
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//INT?
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3() { return cINTTerminalRuleCall_3; }
		
		//(('E' | 'e') '-'? INT)?
		public Group getGroup_4() { return cGroup_4; }
		
		//('E' | 'e')
		public Alternatives getAlternatives_4_0() { return cAlternatives_4_0; }
		
		//'E'
		public Keyword getEKeyword_4_0_0() { return cEKeyword_4_0_0; }
		
		//'e'
		public Keyword getEKeyword_4_0_1() { return cEKeyword_4_0_1; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_4_1() { return cHyphenMinusKeyword_4_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_4_2() { return cINTTerminalRuleCall_4_2; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.inria.diverse.Logo.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cParameterAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//Parameter ASM::Parameter:
		//	{ASM::Parameter} name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//{ASM::Parameter} name=ID
		public Group getGroup() { return cGroup; }
		
		//{ASM::Parameter}
		public Action getParameterAction_0() { return cParameterAction_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
	}
	
	
	private final LogoProgramElements pLogoProgram;
	private final InstructionElements pInstruction;
	private final ExpressionElements pExpression;
	private final AddExpElements pAddExp;
	private final MultExprElements pMultExpr;
	private final UnaryExpElements pUnaryExp;
	private final PrimaryElements pPrimary;
	private final BackElements pBack;
	private final ForwardElements pForward;
	private final LeftElements pLeft;
	private final RightElements pRight;
	private final PenDownElements pPenDown;
	private final PenUpElements pPenUp;
	private final ClearElements pClear;
	private final ConstantElements pConstant;
	private final ProcCallElements pProcCall;
	private final ProcDeclarationElements pProcDeclaration;
	private final BlockElements pBlock;
	private final IfElements pIf;
	private final RepeatElements pRepeat;
	private final WhileElements pWhile;
	private final ParameterCallElements pParameterCall;
	private final CosElements pCos;
	private final SinElements pSin;
	private final TanElements pTan;
	private final EDoubleElements pEDouble;
	private final ParameterElements pParameter;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LogoGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pLogoProgram = new LogoProgramElements();
		this.pInstruction = new InstructionElements();
		this.pExpression = new ExpressionElements();
		this.pAddExp = new AddExpElements();
		this.pMultExpr = new MultExprElements();
		this.pUnaryExp = new UnaryExpElements();
		this.pPrimary = new PrimaryElements();
		this.pBack = new BackElements();
		this.pForward = new ForwardElements();
		this.pLeft = new LeftElements();
		this.pRight = new RightElements();
		this.pPenDown = new PenDownElements();
		this.pPenUp = new PenUpElements();
		this.pClear = new ClearElements();
		this.pConstant = new ConstantElements();
		this.pProcCall = new ProcCallElements();
		this.pProcDeclaration = new ProcDeclarationElements();
		this.pBlock = new BlockElements();
		this.pIf = new IfElements();
		this.pRepeat = new RepeatElements();
		this.pWhile = new WhileElements();
		this.pParameterCall = new ParameterCallElements();
		this.pCos = new CosElements();
		this.pSin = new SinElements();
		this.pTan = new TanElements();
		this.pEDouble = new EDoubleElements();
		this.pParameter = new ParameterElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("fr.inria.diverse.Logo".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//LogoProgram ASM::LogoProgram:
	//	{ASM::LogoProgram}
	//	'LogoProgram'
	//	'{' (instructions+=Instruction (";" instructions+=Instruction)*)?
	//	'}';
	public LogoProgramElements getLogoProgramAccess() {
		return pLogoProgram;
	}
	
	public ParserRule getLogoProgramRule() {
		return getLogoProgramAccess().getRule();
	}
	
	//Instruction ASM::Instruction:
	//	Back | Forward | Left | Right | PenDown | PenUp | Clear | ProcCall | ProcDeclaration | Block | If | Repeat | While;
	public InstructionElements getInstructionAccess() {
		return pInstruction;
	}
	
	public ParserRule getInstructionRule() {
		return getInstructionAccess().getRule();
	}
	
	//Expression ASM::Expression:
	//	AddExp (-> '==' {ASM::Equals.lhs=current} rhs=Expression | -> '>' {ASM::Greater.lhs=current} rhs=Expression | -> '<'
	//	{ASM::Lower.lhs=current} rhs=Expression)?;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//AddExp ASM::Expression:
	//	MultExpr (-> '+' {ASM::Plus.lhs=current} rhs=Expression | -> '-' {ASM::Minus.lhs=current} rhs=Expression)?;
	public AddExpElements getAddExpAccess() {
		return pAddExp;
	}
	
	public ParserRule getAddExpRule() {
		return getAddExpAccess().getRule();
	}
	
	//MultExpr ASM::Expression:
	//	UnaryExp (-> '*' {ASM::Mult.lhs=current} rhs=Expression | -> '/' {ASM::Div.lhs=current} rhs=Expression)?;
	public MultExprElements getMultExprAccess() {
		return pMultExpr;
	}
	
	public ParserRule getMultExprRule() {
		return getMultExprAccess().getRule();
	}
	
	//UnaryExp ASM::Expression:
	//	Cos | Sin | Tan | ProcCall | Primary;
	public UnaryExpElements getUnaryExpAccess() {
		return pUnaryExp;
	}
	
	public ParserRule getUnaryExpRule() {
		return getUnaryExpAccess().getRule();
	}
	
	//Primary ASM::Expression:
	//	Constant | ParameterCall;
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}
	
	//Back ASM::Back:
	//	{ASM::Back}
	//	'Back' steps=Expression;
	public BackElements getBackAccess() {
		return pBack;
	}
	
	public ParserRule getBackRule() {
		return getBackAccess().getRule();
	}
	
	//Forward ASM::Forward:
	//	{ASM::Forward}
	//	'Forward'
	//	steps=Expression;
	public ForwardElements getForwardAccess() {
		return pForward;
	}
	
	public ParserRule getForwardRule() {
		return getForwardAccess().getRule();
	}
	
	//Left ASM::Left:
	//	{ASM::Left}
	//	'Left' angle=Expression;
	public LeftElements getLeftAccess() {
		return pLeft;
	}
	
	public ParserRule getLeftRule() {
		return getLeftAccess().getRule();
	}
	
	//Right ASM::Right:
	//	{ASM::Right}
	//	'Right' angle=Expression;
	public RightElements getRightAccess() {
		return pRight;
	}
	
	public ParserRule getRightRule() {
		return getRightAccess().getRule();
	}
	
	//PenDown ASM::PenDown:
	//	{ASM::PenDown}
	//	'PenDown';
	public PenDownElements getPenDownAccess() {
		return pPenDown;
	}
	
	public ParserRule getPenDownRule() {
		return getPenDownAccess().getRule();
	}
	
	//PenUp ASM::PenUp:
	//	{ASM::PenUp}
	//	'PenUp';
	public PenUpElements getPenUpAccess() {
		return pPenUp;
	}
	
	public ParserRule getPenUpRule() {
		return getPenUpAccess().getRule();
	}
	
	//Clear ASM::Clear:
	//	{ASM::Clear}
	//	'Clear';
	public ClearElements getClearAccess() {
		return pClear;
	}
	
	public ParserRule getClearRule() {
		return getClearAccess().getRule();
	}
	
	//Constant ASM::Constant:
	//	{ASM::Constant} value=EDouble;
	public ConstantElements getConstantAccess() {
		return pConstant;
	}
	
	public ParserRule getConstantRule() {
		return getConstantAccess().getRule();
	}
	
	//ProcCall ASM::ProcCall:
	//	{ASM::ProcCall} declaration=[ASM::ProcDeclaration] '(' (actualArgs+=Expression ("," actualArgs+=Expression)*)? ')';
	public ProcCallElements getProcCallAccess() {
		return pProcCall;
	}
	
	public ParserRule getProcCallRule() {
		return getProcCallAccess().getRule();
	}
	
	//ProcDeclaration ASM::ProcDeclaration:
	//	{ASM::ProcDeclaration}
	//	'Proc' name=ID '(' (args+=Parameter ("," args+=Parameter)*)? ')'
	//	'{' (instructions+=Instruction (";" instructions+=Instruction)*)? ('Return' instructions+=Expression)?
	//	'}';
	public ProcDeclarationElements getProcDeclarationAccess() {
		return pProcDeclaration;
	}
	
	public ParserRule getProcDeclarationRule() {
		return getProcDeclarationAccess().getRule();
	}
	
	//Block ASM::Block:
	//	{ASM::Block}
	//	'{' (instructions+=Instruction (";" instructions+=Instruction)*)?
	//	'}';
	public BlockElements getBlockAccess() {
		return pBlock;
	}
	
	public ParserRule getBlockRule() {
		return getBlockAccess().getRule();
	}
	
	//If ASM::If:
	//	{ASM::If}
	//	'If' condition=Expression
	//	thenPart=Block
	//	elsePart=Block?;
	public IfElements getIfAccess() {
		return pIf;
	}
	
	public ParserRule getIfRule() {
		return getIfAccess().getRule();
	}
	
	//Repeat ASM::Repeat:
	//	{ASM::Repeat}
	//	'Repeat' condition=Expression
	//	block=Block;
	public RepeatElements getRepeatAccess() {
		return pRepeat;
	}
	
	public ParserRule getRepeatRule() {
		return getRepeatAccess().getRule();
	}
	
	//While ASM::While:
	//	{ASM::While}
	//	'While' condition=Expression
	//	block=Block;
	public WhileElements getWhileAccess() {
		return pWhile;
	}
	
	public ParserRule getWhileRule() {
		return getWhileAccess().getRule();
	}
	
	//ParameterCall ASM::ParameterCall:
	//	{ASM::ParameterCall} parameter=[ASM::Parameter];
	public ParameterCallElements getParameterCallAccess() {
		return pParameterCall;
	}
	
	public ParserRule getParameterCallRule() {
		return getParameterCallAccess().getRule();
	}
	
	//Cos ASM::Cos:
	//	{ASM::Cos}
	//	'Cos' expression=Expression;
	public CosElements getCosAccess() {
		return pCos;
	}
	
	public ParserRule getCosRule() {
		return getCosAccess().getRule();
	}
	
	//Sin ASM::Sin:
	//	{ASM::Sin}
	//	'Sin' expression=Expression;
	public SinElements getSinAccess() {
		return pSin;
	}
	
	public ParserRule getSinRule() {
		return getSinAccess().getRule();
	}
	
	//Tan ASM::Tan:
	//	{ASM::Tan}
	//	'Tan' expression=Expression;
	public TanElements getTanAccess() {
		return pTan;
	}
	
	public ParserRule getTanRule() {
		return getTanAccess().getRule();
	}
	
	//EDouble ecore::EDouble:
	//	'-'? INT? '.' INT (('E' | 'e') '-'? INT)?;
	public EDoubleElements getEDoubleAccess() {
		return pEDouble;
	}
	
	public ParserRule getEDoubleRule() {
		return getEDoubleAccess().getRule();
	}
	
	//Parameter ASM::Parameter:
	//	{ASM::Parameter} name=ID;
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
