/*
 * generated by Xtext 2.19.0
 */
package fr.inria.diverse.serializer;

import com.google.inject.Inject;
import fr.inria.diverse.services.LogoGrammarAccess;
import java.util.Set;
import kmLogo.ASM.ASMPackage;
import kmLogo.ASM.Back;
import kmLogo.ASM.Block;
import kmLogo.ASM.Clear;
import kmLogo.ASM.Constant;
import kmLogo.ASM.Cos;
import kmLogo.ASM.Div;
import kmLogo.ASM.Equals;
import kmLogo.ASM.Forward;
import kmLogo.ASM.Greater;
import kmLogo.ASM.If;
import kmLogo.ASM.Left;
import kmLogo.ASM.LogoProgram;
import kmLogo.ASM.Lower;
import kmLogo.ASM.Minus;
import kmLogo.ASM.Mult;
import kmLogo.ASM.ParameterCall;
import kmLogo.ASM.PenDown;
import kmLogo.ASM.PenUp;
import kmLogo.ASM.Plus;
import kmLogo.ASM.ProcCall;
import kmLogo.ASM.ProcDeclaration;
import kmLogo.ASM.Repeat;
import kmLogo.ASM.Right;
import kmLogo.ASM.Sin;
import kmLogo.ASM.Tan;
import kmLogo.ASM.While;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LogoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LogoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ASMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ASMPackage.BACK:
				sequence_Back(context, (Back) semanticObject); 
				return; 
			case ASMPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case ASMPackage.CLEAR:
				sequence_Clear(context, (Clear) semanticObject); 
				return; 
			case ASMPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case ASMPackage.COS:
				sequence_Cos(context, (Cos) semanticObject); 
				return; 
			case ASMPackage.DIV:
				sequence_MultExpr(context, (Div) semanticObject); 
				return; 
			case ASMPackage.EQUALS:
				sequence_Expression(context, (Equals) semanticObject); 
				return; 
			case ASMPackage.FORWARD:
				sequence_Forward(context, (Forward) semanticObject); 
				return; 
			case ASMPackage.GREATER:
				sequence_Expression(context, (Greater) semanticObject); 
				return; 
			case ASMPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case ASMPackage.LEFT:
				sequence_Left(context, (Left) semanticObject); 
				return; 
			case ASMPackage.LOGO_PROGRAM:
				sequence_LogoProgram(context, (LogoProgram) semanticObject); 
				return; 
			case ASMPackage.LOWER:
				sequence_Expression(context, (Lower) semanticObject); 
				return; 
			case ASMPackage.MINUS:
				sequence_AddExp(context, (Minus) semanticObject); 
				return; 
			case ASMPackage.MULT:
				sequence_MultExpr(context, (Mult) semanticObject); 
				return; 
			case ASMPackage.PARAMETER:
				sequence_Parameter(context, (kmLogo.ASM.Parameter) semanticObject); 
				return; 
			case ASMPackage.PARAMETER_CALL:
				sequence_ParameterCall(context, (ParameterCall) semanticObject); 
				return; 
			case ASMPackage.PEN_DOWN:
				sequence_PenDown(context, (PenDown) semanticObject); 
				return; 
			case ASMPackage.PEN_UP:
				sequence_PenUp(context, (PenUp) semanticObject); 
				return; 
			case ASMPackage.PLUS:
				sequence_AddExp(context, (Plus) semanticObject); 
				return; 
			case ASMPackage.PROC_CALL:
				sequence_ProcCall(context, (ProcCall) semanticObject); 
				return; 
			case ASMPackage.PROC_DECLARATION:
				sequence_ProcDeclaration(context, (ProcDeclaration) semanticObject); 
				return; 
			case ASMPackage.REPEAT:
				sequence_Repeat(context, (Repeat) semanticObject); 
				return; 
			case ASMPackage.RIGHT:
				sequence_Right(context, (Right) semanticObject); 
				return; 
			case ASMPackage.SIN:
				sequence_Sin(context, (Sin) semanticObject); 
				return; 
			case ASMPackage.TAN:
				sequence_Tan(context, (Tan) semanticObject); 
				return; 
			case ASMPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Expression.Equals_1_0_1 returns Minus
	 *     Expression.Greater_1_1_1 returns Minus
	 *     Expression.Lower_1_2_1 returns Minus
	 *     AddExp returns Minus
	 *
	 * Constraint:
	 *     (lhs=AddExp_Minus_1_1_1 rhs=Expression)
	 */
	protected void sequence_AddExp(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddExpAccess().getMinusLhsAction_1_1_1(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAddExpAccess().getRhsExpressionParserRuleCall_1_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Expression.Equals_1_0_1 returns Plus
	 *     Expression.Greater_1_1_1 returns Plus
	 *     Expression.Lower_1_2_1 returns Plus
	 *     AddExp returns Plus
	 *
	 * Constraint:
	 *     (lhs=AddExp_Plus_1_0_1 rhs=Expression)
	 */
	protected void sequence_AddExp(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddExpAccess().getPlusLhsAction_1_0_1(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAddExpAccess().getRhsExpressionParserRuleCall_1_0_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Back
	 *     Back returns Back
	 *
	 * Constraint:
	 *     steps=Expression
	 */
	protected void sequence_Back(ISerializationContext context, Back semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BACK__STEPS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BACK__STEPS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBackAccess().getStepsExpressionParserRuleCall_2_0(), semanticObject.getSteps());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     (instructions+=Instruction instructions+=Instruction*)?
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Clear
	 *     Clear returns Clear
	 *
	 * Constraint:
	 *     {Clear}
	 */
	protected void sequence_Clear(ISerializationContext context, Clear semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Constant
	 *     Expression.Equals_1_0_1 returns Constant
	 *     Expression.Greater_1_1_1 returns Constant
	 *     Expression.Lower_1_2_1 returns Constant
	 *     AddExp returns Constant
	 *     AddExp.Plus_1_0_1 returns Constant
	 *     AddExp.Minus_1_1_1 returns Constant
	 *     MultExpr returns Constant
	 *     MultExpr.Mult_1_0_1 returns Constant
	 *     MultExpr.Div_1_1_1 returns Constant
	 *     UnaryExp returns Constant
	 *     Primary returns Constant
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     value=EDouble
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getValueEDoubleParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Cos
	 *     Expression.Equals_1_0_1 returns Cos
	 *     Expression.Greater_1_1_1 returns Cos
	 *     Expression.Lower_1_2_1 returns Cos
	 *     AddExp returns Cos
	 *     AddExp.Plus_1_0_1 returns Cos
	 *     AddExp.Minus_1_1_1 returns Cos
	 *     MultExpr returns Cos
	 *     MultExpr.Mult_1_0_1 returns Cos
	 *     MultExpr.Div_1_1_1 returns Cos
	 *     UnaryExp returns Cos
	 *     Cos returns Cos
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Cos(ISerializationContext context, Cos semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.UNARY_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.UNARY_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCosAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equals
	 *
	 * Constraint:
	 *     (lhs=Expression_Equals_1_0_1 rhs=Expression)
	 */
	protected void sequence_Expression(ISerializationContext context, Equals semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getEqualsLhsAction_1_0_1(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getExpressionAccess().getRhsExpressionParserRuleCall_1_0_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Greater
	 *
	 * Constraint:
	 *     (lhs=Expression_Greater_1_1_1 rhs=Expression)
	 */
	protected void sequence_Expression(ISerializationContext context, Greater semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getGreaterLhsAction_1_1_1(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getExpressionAccess().getRhsExpressionParserRuleCall_1_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Lower
	 *
	 * Constraint:
	 *     (lhs=Expression_Lower_1_2_1 rhs=Expression)
	 */
	protected void sequence_Expression(ISerializationContext context, Lower semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getLowerLhsAction_1_2_1(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getExpressionAccess().getRhsExpressionParserRuleCall_1_2_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Forward
	 *     Forward returns Forward
	 *
	 * Constraint:
	 *     steps=Expression
	 */
	protected void sequence_Forward(ISerializationContext context, Forward semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.FORWARD__STEPS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.FORWARD__STEPS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForwardAccess().getStepsExpressionParserRuleCall_2_0(), semanticObject.getSteps());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns If
	 *     If returns If
	 *
	 * Constraint:
	 *     (condition=Expression thenPart=Block elsePart=Block?)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Left
	 *     Left returns Left
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_Left(ISerializationContext context, Left semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.LEFT__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.LEFT__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLeftAccess().getAngleExpressionParserRuleCall_2_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogoProgram returns LogoProgram
	 *
	 * Constraint:
	 *     (instructions+=Instruction instructions+=Instruction*)?
	 */
	protected void sequence_LogoProgram(ISerializationContext context, LogoProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Div
	 *     Expression.Equals_1_0_1 returns Div
	 *     Expression.Greater_1_1_1 returns Div
	 *     Expression.Lower_1_2_1 returns Div
	 *     AddExp returns Div
	 *     AddExp.Plus_1_0_1 returns Div
	 *     AddExp.Minus_1_1_1 returns Div
	 *     MultExpr returns Div
	 *
	 * Constraint:
	 *     (lhs=MultExpr_Div_1_1_1 rhs=Expression)
	 */
	protected void sequence_MultExpr(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultExprAccess().getDivLhsAction_1_1_1(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getMultExprAccess().getRhsExpressionParserRuleCall_1_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Mult
	 *     Expression.Equals_1_0_1 returns Mult
	 *     Expression.Greater_1_1_1 returns Mult
	 *     Expression.Lower_1_2_1 returns Mult
	 *     AddExp returns Mult
	 *     AddExp.Plus_1_0_1 returns Mult
	 *     AddExp.Minus_1_1_1 returns Mult
	 *     MultExpr returns Mult
	 *
	 * Constraint:
	 *     (lhs=MultExpr_Mult_1_0_1 rhs=Expression)
	 */
	protected void sequence_MultExpr(ISerializationContext context, Mult semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__LHS));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.BINARY_EXP__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultExprAccess().getMultLhsAction_1_0_1(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getMultExprAccess().getRhsExpressionParserRuleCall_1_0_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ParameterCall
	 *     Expression.Equals_1_0_1 returns ParameterCall
	 *     Expression.Greater_1_1_1 returns ParameterCall
	 *     Expression.Lower_1_2_1 returns ParameterCall
	 *     AddExp returns ParameterCall
	 *     AddExp.Plus_1_0_1 returns ParameterCall
	 *     AddExp.Minus_1_1_1 returns ParameterCall
	 *     MultExpr returns ParameterCall
	 *     MultExpr.Mult_1_0_1 returns ParameterCall
	 *     MultExpr.Div_1_1_1 returns ParameterCall
	 *     UnaryExp returns ParameterCall
	 *     Primary returns ParameterCall
	 *     ParameterCall returns ParameterCall
	 *
	 * Constraint:
	 *     parameter=[Parameter|ID]
	 */
	protected void sequence_ParameterCall(ISerializationContext context, ParameterCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.PARAMETER_CALL__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.PARAMETER_CALL__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterCallAccess().getParameterParameterIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ASMPackage.Literals.PARAMETER_CALL__PARAMETER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(ISerializationContext context, kmLogo.ASM.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns PenDown
	 *     PenDown returns PenDown
	 *
	 * Constraint:
	 *     {PenDown}
	 */
	protected void sequence_PenDown(ISerializationContext context, PenDown semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns PenUp
	 *     PenUp returns PenUp
	 *
	 * Constraint:
	 *     {PenUp}
	 */
	protected void sequence_PenUp(ISerializationContext context, PenUp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns ProcCall
	 *     Expression returns ProcCall
	 *     Expression.Equals_1_0_1 returns ProcCall
	 *     Expression.Greater_1_1_1 returns ProcCall
	 *     Expression.Lower_1_2_1 returns ProcCall
	 *     AddExp returns ProcCall
	 *     AddExp.Plus_1_0_1 returns ProcCall
	 *     AddExp.Minus_1_1_1 returns ProcCall
	 *     MultExpr returns ProcCall
	 *     MultExpr.Mult_1_0_1 returns ProcCall
	 *     MultExpr.Div_1_1_1 returns ProcCall
	 *     UnaryExp returns ProcCall
	 *     ProcCall returns ProcCall
	 *
	 * Constraint:
	 *     (declaration=[ProcDeclaration|ID] (actualArgs+=Expression actualArgs+=Expression*)?)
	 */
	protected void sequence_ProcCall(ISerializationContext context, ProcCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns ProcDeclaration
	 *     ProcDeclaration returns ProcDeclaration
	 *
	 * Constraint:
	 *     (name=ID (args+=Parameter args+=Parameter*)? (instructions+=Instruction instructions+=Instruction*)? instructions+=Expression?)
	 */
	protected void sequence_ProcDeclaration(ISerializationContext context, ProcDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Repeat
	 *     Repeat returns Repeat
	 *
	 * Constraint:
	 *     (condition=Expression block=Block)
	 */
	protected void sequence_Repeat(ISerializationContext context, Repeat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.CONTROL_STRUCTURE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.CONTROL_STRUCTURE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.REPEAT__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.REPEAT__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getRepeatAccess().getBlockBlockParserRuleCall_3_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Right
	 *     Right returns Right
	 *
	 * Constraint:
	 *     angle=Expression
	 */
	protected void sequence_Right(ISerializationContext context, Right semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.RIGHT__ANGLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.RIGHT__ANGLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRightAccess().getAngleExpressionParserRuleCall_2_0(), semanticObject.getAngle());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Sin
	 *     Expression.Equals_1_0_1 returns Sin
	 *     Expression.Greater_1_1_1 returns Sin
	 *     Expression.Lower_1_2_1 returns Sin
	 *     AddExp returns Sin
	 *     AddExp.Plus_1_0_1 returns Sin
	 *     AddExp.Minus_1_1_1 returns Sin
	 *     MultExpr returns Sin
	 *     MultExpr.Mult_1_0_1 returns Sin
	 *     MultExpr.Div_1_1_1 returns Sin
	 *     UnaryExp returns Sin
	 *     Sin returns Sin
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Sin(ISerializationContext context, Sin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.UNARY_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.UNARY_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSinAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Tan
	 *     Expression.Equals_1_0_1 returns Tan
	 *     Expression.Greater_1_1_1 returns Tan
	 *     Expression.Lower_1_2_1 returns Tan
	 *     AddExp returns Tan
	 *     AddExp.Plus_1_0_1 returns Tan
	 *     AddExp.Minus_1_1_1 returns Tan
	 *     MultExpr returns Tan
	 *     MultExpr.Mult_1_0_1 returns Tan
	 *     MultExpr.Div_1_1_1 returns Tan
	 *     UnaryExp returns Tan
	 *     Tan returns Tan
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Tan(ISerializationContext context, Tan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.UNARY_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.UNARY_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTanAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns While
	 *     While returns While
	 *
	 * Constraint:
	 *     (condition=Expression block=Block)
	 */
	protected void sequence_While(ISerializationContext context, While semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.CONTROL_STRUCTURE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.CONTROL_STRUCTURE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, ASMPackage.Literals.WHILE__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ASMPackage.Literals.WHILE__BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileAccess().getBlockBlockParserRuleCall_3_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
}
