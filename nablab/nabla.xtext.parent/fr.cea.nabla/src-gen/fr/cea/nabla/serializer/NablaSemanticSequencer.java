/*
 * generated by Xtext 2.19.0
 */
package fr.cea.nabla.serializer;

import com.google.inject.Inject;
import fr.cea.nabla.nabla.Affectation;
import fr.cea.nabla.nabla.And;
import fr.cea.nabla.nabla.ArrayVar;
import fr.cea.nabla.nabla.BoolConstant;
import fr.cea.nabla.nabla.Comparison;
import fr.cea.nabla.nabla.Connectivity;
import fr.cea.nabla.nabla.ConnectivityDeclarationBlock;
import fr.cea.nabla.nabla.Equality;
import fr.cea.nabla.nabla.Function;
import fr.cea.nabla.nabla.FunctionArg;
import fr.cea.nabla.nabla.FunctionCall;
import fr.cea.nabla.nabla.FunctionDeclarationBlock;
import fr.cea.nabla.nabla.If;
import fr.cea.nabla.nabla.Import;
import fr.cea.nabla.nabla.InstructionBlock;
import fr.cea.nabla.nabla.InstructionJob;
import fr.cea.nabla.nabla.IntConstant;
import fr.cea.nabla.nabla.ItemArgType;
import fr.cea.nabla.nabla.Loop;
import fr.cea.nabla.nabla.MaxConstant;
import fr.cea.nabla.nabla.MinConstant;
import fr.cea.nabla.nabla.Minus;
import fr.cea.nabla.nabla.MulOrDiv;
import fr.cea.nabla.nabla.NablaModule;
import fr.cea.nabla.nabla.NablaPackage;
import fr.cea.nabla.nabla.Not;
import fr.cea.nabla.nabla.Or;
import fr.cea.nabla.nabla.Parenthesis;
import fr.cea.nabla.nabla.Plus;
import fr.cea.nabla.nabla.Real2Constant;
import fr.cea.nabla.nabla.Real2x2Constant;
import fr.cea.nabla.nabla.Real3Constant;
import fr.cea.nabla.nabla.Real3x3Constant;
import fr.cea.nabla.nabla.RealConstant;
import fr.cea.nabla.nabla.RealXCompactConstant;
import fr.cea.nabla.nabla.Reduction;
import fr.cea.nabla.nabla.ReductionArg;
import fr.cea.nabla.nabla.ReductionCall;
import fr.cea.nabla.nabla.ScalarVar;
import fr.cea.nabla.nabla.ScalarVarDefinition;
import fr.cea.nabla.nabla.SpaceIterator;
import fr.cea.nabla.nabla.SpaceIteratorRange;
import fr.cea.nabla.nabla.SpaceIteratorRef;
import fr.cea.nabla.nabla.TimeIterator;
import fr.cea.nabla.nabla.TimeIteratorRef;
import fr.cea.nabla.nabla.TimeLoopJob;
import fr.cea.nabla.nabla.UnaryMinus;
import fr.cea.nabla.nabla.VarGroupDeclaration;
import fr.cea.nabla.nabla.VarRef;
import fr.cea.nabla.services.NablaGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class NablaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private NablaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == NablaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NablaPackage.AFFECTATION:
				sequence_Instruction(context, (Affectation) semanticObject); 
				return; 
			case NablaPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case NablaPackage.ARRAY_VAR:
				sequence_ArrayVar(context, (ArrayVar) semanticObject); 
				return; 
			case NablaPackage.BOOL_CONSTANT:
				sequence_Atomic(context, (BoolConstant) semanticObject); 
				return; 
			case NablaPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case NablaPackage.CONNECTIVITY:
				sequence_Connectivity(context, (Connectivity) semanticObject); 
				return; 
			case NablaPackage.CONNECTIVITY_DECLARATION_BLOCK:
				sequence_DeclarationBlock(context, (ConnectivityDeclarationBlock) semanticObject); 
				return; 
			case NablaPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case NablaPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case NablaPackage.FUNCTION_ARG:
				sequence_FunctionArg(context, (FunctionArg) semanticObject); 
				return; 
			case NablaPackage.FUNCTION_CALL:
				sequence_Atomic(context, (FunctionCall) semanticObject); 
				return; 
			case NablaPackage.FUNCTION_DECLARATION_BLOCK:
				sequence_DeclarationBlock(context, (FunctionDeclarationBlock) semanticObject); 
				return; 
			case NablaPackage.IF:
				sequence_Instruction(context, (If) semanticObject); 
				return; 
			case NablaPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case NablaPackage.INSTRUCTION_BLOCK:
				sequence_Instruction(context, (InstructionBlock) semanticObject); 
				return; 
			case NablaPackage.INSTRUCTION_JOB:
				sequence_Job(context, (InstructionJob) semanticObject); 
				return; 
			case NablaPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case NablaPackage.ITEM_ARG_TYPE:
				sequence_ItemArgType(context, (ItemArgType) semanticObject); 
				return; 
			case NablaPackage.LOOP:
				sequence_Instruction(context, (Loop) semanticObject); 
				return; 
			case NablaPackage.MAX_CONSTANT:
				sequence_Atomic(context, (MaxConstant) semanticObject); 
				return; 
			case NablaPackage.MIN_CONSTANT:
				sequence_Atomic(context, (MinConstant) semanticObject); 
				return; 
			case NablaPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case NablaPackage.MUL_OR_DIV:
				sequence_MulOrDiv(context, (MulOrDiv) semanticObject); 
				return; 
			case NablaPackage.NABLA_MODULE:
				sequence_NablaModule(context, (NablaModule) semanticObject); 
				return; 
			case NablaPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case NablaPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case NablaPackage.PARENTHESIS:
				sequence_Primary(context, (Parenthesis) semanticObject); 
				return; 
			case NablaPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case NablaPackage.REAL2_CONSTANT:
				sequence_Real2Constant(context, (Real2Constant) semanticObject); 
				return; 
			case NablaPackage.REAL2X2_CONSTANT:
				sequence_Atomic(context, (Real2x2Constant) semanticObject); 
				return; 
			case NablaPackage.REAL3_CONSTANT:
				sequence_Real3Constant(context, (Real3Constant) semanticObject); 
				return; 
			case NablaPackage.REAL3X3_CONSTANT:
				sequence_Atomic(context, (Real3x3Constant) semanticObject); 
				return; 
			case NablaPackage.REAL_CONSTANT:
				sequence_Atomic(context, (RealConstant) semanticObject); 
				return; 
			case NablaPackage.REAL_XCOMPACT_CONSTANT:
				sequence_Atomic(context, (RealXCompactConstant) semanticObject); 
				return; 
			case NablaPackage.REDUCTION:
				sequence_Reduction(context, (Reduction) semanticObject); 
				return; 
			case NablaPackage.REDUCTION_ARG:
				sequence_ReductionArg(context, (ReductionArg) semanticObject); 
				return; 
			case NablaPackage.REDUCTION_CALL:
				sequence_Atomic(context, (ReductionCall) semanticObject); 
				return; 
			case NablaPackage.SCALAR_VAR:
				sequence_ScalarVar(context, (ScalarVar) semanticObject); 
				return; 
			case NablaPackage.SCALAR_VAR_DEFINITION:
				sequence_ScalarVarDefinition(context, (ScalarVarDefinition) semanticObject); 
				return; 
			case NablaPackage.SPACE_ITERATOR:
				sequence_SpaceIterator(context, (SpaceIterator) semanticObject); 
				return; 
			case NablaPackage.SPACE_ITERATOR_RANGE:
				sequence_SpaceIteratorRange(context, (SpaceIteratorRange) semanticObject); 
				return; 
			case NablaPackage.SPACE_ITERATOR_REF:
				sequence_SpaceIteratorRef(context, (SpaceIteratorRef) semanticObject); 
				return; 
			case NablaPackage.TIME_ITERATOR:
				sequence_TimeIterator(context, (TimeIterator) semanticObject); 
				return; 
			case NablaPackage.TIME_ITERATOR_REF:
				sequence_TimeIteratorRef(context, (TimeIteratorRef) semanticObject); 
				return; 
			case NablaPackage.TIME_LOOP_JOB:
				sequence_Job(context, (TimeLoopJob) semanticObject); 
				return; 
			case NablaPackage.UNARY_MINUS:
				sequence_Primary(context, (UnaryMinus) semanticObject); 
				return; 
			case NablaPackage.VAR_GROUP_DECLARATION:
				sequence_VarGroupDeclaration(context, (VarGroupDeclaration) semanticObject); 
				return; 
			case NablaPackage.VAR_REF:
				sequence_VarRef(context, (VarRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 op='&&' right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.AND__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.AND__OP));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getOpAmpersandAmpersandKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Var returns ArrayVar
	 *     ArrayVar returns ArrayVar
	 *
	 * Constraint:
	 *     (name=ID dimensions+=[Connectivity|ID] dimensions+=[Connectivity|ID]*)
	 */
	protected void sequence_ArrayVar(ISerializationContext context, ArrayVar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolConstant
	 *     Or returns BoolConstant
	 *     Or.Or_1_0 returns BoolConstant
	 *     And returns BoolConstant
	 *     And.And_1_0 returns BoolConstant
	 *     Equality returns BoolConstant
	 *     Equality.Equality_1_0 returns BoolConstant
	 *     Comparison returns BoolConstant
	 *     Comparison.Comparison_1_0 returns BoolConstant
	 *     PlusOrMinus returns BoolConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns BoolConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns BoolConstant
	 *     MulOrDiv returns BoolConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns BoolConstant
	 *     Primary returns BoolConstant
	 *     Atomic returns BoolConstant
	 *
	 * Constraint:
	 *     value?='true'?
	 */
	protected void sequence_Atomic(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionCall
	 *     Or returns FunctionCall
	 *     Or.Or_1_0 returns FunctionCall
	 *     And returns FunctionCall
	 *     And.And_1_0 returns FunctionCall
	 *     Equality returns FunctionCall
	 *     Equality.Equality_1_0 returns FunctionCall
	 *     Comparison returns FunctionCall
	 *     Comparison.Comparison_1_0 returns FunctionCall
	 *     PlusOrMinus returns FunctionCall
	 *     PlusOrMinus.Plus_1_0_0_0 returns FunctionCall
	 *     PlusOrMinus.Minus_1_0_1_0 returns FunctionCall
	 *     MulOrDiv returns FunctionCall
	 *     MulOrDiv.MulOrDiv_1_0 returns FunctionCall
	 *     Primary returns FunctionCall
	 *     Atomic returns FunctionCall
	 *
	 * Constraint:
	 *     (function=[Function|QualifiedName] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_Atomic(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MaxConstant
	 *     Or returns MaxConstant
	 *     Or.Or_1_0 returns MaxConstant
	 *     And returns MaxConstant
	 *     And.And_1_0 returns MaxConstant
	 *     Equality returns MaxConstant
	 *     Equality.Equality_1_0 returns MaxConstant
	 *     Comparison returns MaxConstant
	 *     Comparison.Comparison_1_0 returns MaxConstant
	 *     PlusOrMinus returns MaxConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns MaxConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns MaxConstant
	 *     MulOrDiv returns MaxConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns MaxConstant
	 *     Primary returns MaxConstant
	 *     Atomic returns MaxConstant
	 *
	 * Constraint:
	 *     type=BasicType
	 */
	protected void sequence_Atomic(ISerializationContext context, MaxConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.MAX_CONSTANT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.MAX_CONSTANT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getTypeBasicTypeEnumRuleCall_9_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MinConstant
	 *     Or returns MinConstant
	 *     Or.Or_1_0 returns MinConstant
	 *     And returns MinConstant
	 *     And.And_1_0 returns MinConstant
	 *     Equality returns MinConstant
	 *     Equality.Equality_1_0 returns MinConstant
	 *     Comparison returns MinConstant
	 *     Comparison.Comparison_1_0 returns MinConstant
	 *     PlusOrMinus returns MinConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns MinConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns MinConstant
	 *     MulOrDiv returns MinConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns MinConstant
	 *     Primary returns MinConstant
	 *     Atomic returns MinConstant
	 *
	 * Constraint:
	 *     type=BasicType
	 */
	protected void sequence_Atomic(ISerializationContext context, MinConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.MIN_CONSTANT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.MIN_CONSTANT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getTypeBasicTypeEnumRuleCall_8_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Real2x2Constant
	 *     Or returns Real2x2Constant
	 *     Or.Or_1_0 returns Real2x2Constant
	 *     And returns Real2x2Constant
	 *     And.And_1_0 returns Real2x2Constant
	 *     Equality returns Real2x2Constant
	 *     Equality.Equality_1_0 returns Real2x2Constant
	 *     Comparison returns Real2x2Constant
	 *     Comparison.Comparison_1_0 returns Real2x2Constant
	 *     PlusOrMinus returns Real2x2Constant
	 *     PlusOrMinus.Plus_1_0_0_0 returns Real2x2Constant
	 *     PlusOrMinus.Minus_1_0_1_0 returns Real2x2Constant
	 *     MulOrDiv returns Real2x2Constant
	 *     MulOrDiv.MulOrDiv_1_0 returns Real2x2Constant
	 *     Primary returns Real2x2Constant
	 *     Atomic returns Real2x2Constant
	 *
	 * Constraint:
	 *     (x=Real2Constant y=Real2Constant)
	 */
	protected void sequence_Atomic(ISerializationContext context, Real2x2Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL2X2_CONSTANT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL2X2_CONSTANT__X));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL2X2_CONSTANT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL2X2_CONSTANT__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getXReal2ConstantParserRuleCall_5_2_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAtomicAccess().getYReal2ConstantParserRuleCall_5_4_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Real3x3Constant
	 *     Or returns Real3x3Constant
	 *     Or.Or_1_0 returns Real3x3Constant
	 *     And returns Real3x3Constant
	 *     And.And_1_0 returns Real3x3Constant
	 *     Equality returns Real3x3Constant
	 *     Equality.Equality_1_0 returns Real3x3Constant
	 *     Comparison returns Real3x3Constant
	 *     Comparison.Comparison_1_0 returns Real3x3Constant
	 *     PlusOrMinus returns Real3x3Constant
	 *     PlusOrMinus.Plus_1_0_0_0 returns Real3x3Constant
	 *     PlusOrMinus.Minus_1_0_1_0 returns Real3x3Constant
	 *     MulOrDiv returns Real3x3Constant
	 *     MulOrDiv.MulOrDiv_1_0 returns Real3x3Constant
	 *     Primary returns Real3x3Constant
	 *     Atomic returns Real3x3Constant
	 *
	 * Constraint:
	 *     (x=Real3Constant y=Real3Constant z=Real3Constant)
	 */
	protected void sequence_Atomic(ISerializationContext context, Real3x3Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL3X3_CONSTANT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL3X3_CONSTANT__X));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL3X3_CONSTANT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL3X3_CONSTANT__Y));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL3X3_CONSTANT__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL3X3_CONSTANT__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getXReal3ConstantParserRuleCall_6_2_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getAtomicAccess().getYReal3ConstantParserRuleCall_6_4_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getAtomicAccess().getZReal3ConstantParserRuleCall_6_6_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RealConstant
	 *     Or returns RealConstant
	 *     Or.Or_1_0 returns RealConstant
	 *     And returns RealConstant
	 *     And.And_1_0 returns RealConstant
	 *     Equality returns RealConstant
	 *     Equality.Equality_1_0 returns RealConstant
	 *     Comparison returns RealConstant
	 *     Comparison.Comparison_1_0 returns RealConstant
	 *     PlusOrMinus returns RealConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns RealConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns RealConstant
	 *     MulOrDiv returns RealConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns RealConstant
	 *     Primary returns RealConstant
	 *     Atomic returns RealConstant
	 *
	 * Constraint:
	 *     value=REAL
	 */
	protected void sequence_Atomic(ISerializationContext context, RealConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueREALTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RealXCompactConstant
	 *     Or returns RealXCompactConstant
	 *     Or.Or_1_0 returns RealXCompactConstant
	 *     And returns RealXCompactConstant
	 *     And.And_1_0 returns RealXCompactConstant
	 *     Equality returns RealXCompactConstant
	 *     Equality.Equality_1_0 returns RealXCompactConstant
	 *     Comparison returns RealXCompactConstant
	 *     Comparison.Comparison_1_0 returns RealXCompactConstant
	 *     PlusOrMinus returns RealXCompactConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns RealXCompactConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns RealXCompactConstant
	 *     MulOrDiv returns RealXCompactConstant
	 *     MulOrDiv.MulOrDiv_1_0 returns RealXCompactConstant
	 *     Primary returns RealXCompactConstant
	 *     Atomic returns RealXCompactConstant
	 *
	 * Constraint:
	 *     (type=BasicType value=REAL)
	 */
	protected void sequence_Atomic(ISerializationContext context, RealXCompactConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL_XCOMPACT_CONSTANT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL_XCOMPACT_CONSTANT__TYPE));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL_XCOMPACT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL_XCOMPACT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getTypeBasicTypeEnumRuleCall_7_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getAtomicAccess().getValueREALTerminalRuleCall_7_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ReductionCall
	 *     Or returns ReductionCall
	 *     Or.Or_1_0 returns ReductionCall
	 *     And returns ReductionCall
	 *     And.And_1_0 returns ReductionCall
	 *     Equality returns ReductionCall
	 *     Equality.Equality_1_0 returns ReductionCall
	 *     Comparison returns ReductionCall
	 *     Comparison.Comparison_1_0 returns ReductionCall
	 *     PlusOrMinus returns ReductionCall
	 *     PlusOrMinus.Plus_1_0_0_0 returns ReductionCall
	 *     PlusOrMinus.Minus_1_0_1_0 returns ReductionCall
	 *     MulOrDiv returns ReductionCall
	 *     MulOrDiv.MulOrDiv_1_0 returns ReductionCall
	 *     Primary returns ReductionCall
	 *     Atomic returns ReductionCall
	 *
	 * Constraint:
	 *     (reduction=[Reduction|QualifiedName] iterator=SpaceIterator arg=Expression)
	 */
	protected void sequence_Atomic(ISerializationContext context, ReductionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REDUCTION_CALL__REDUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REDUCTION_CALL__REDUCTION));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REDUCTION_CALL__ITERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REDUCTION_CALL__ITERATOR));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REDUCTION_CALL__ARG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REDUCTION_CALL__ARG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getReductionReductionQualifiedNameParserRuleCall_11_1_0_1(), semanticObject.eGet(NablaPackage.Literals.REDUCTION_CALL__REDUCTION, false));
		feeder.accept(grammarAccess.getAtomicAccess().getIteratorSpaceIteratorParserRuleCall_11_3_0(), semanticObject.getIterator());
		feeder.accept(grammarAccess.getAtomicAccess().getArgExpressionParserRuleCall_11_6_0(), semanticObject.getArg());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='>=' | op='<=' | op='>' | op='<') right=PlusOrMinus)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Connectivity returns Connectivity
	 *
	 * Constraint:
	 *     (name=ID (inTypes+=ItemType inTypes+=ItemType*)? returnType=ItemArgType)
	 */
	protected void sequence_Connectivity(ISerializationContext context, Connectivity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationBlock returns ConnectivityDeclarationBlock
	 *
	 * Constraint:
	 *     connectivities+=Connectivity*
	 */
	protected void sequence_DeclarationBlock(ISerializationContext context, ConnectivityDeclarationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationBlock returns FunctionDeclarationBlock
	 *
	 * Constraint:
	 *     (functions+=Function | functions+=Reduction)*
	 */
	protected void sequence_DeclarationBlock(ISerializationContext context, FunctionDeclarationBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionArg returns FunctionArg
	 *
	 * Constraint:
	 *     ((inTypes+=BasicType inTypes+=BasicType*)? returnType=BasicType)
	 */
	protected void sequence_FunctionArg(ISerializationContext context, FunctionArg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID argGroups+=FunctionArg argGroups+=FunctionArg*)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Affectation
	 *
	 * Constraint:
	 *     (varRef=VarRef expression=Expression)
	 */
	protected void sequence_Instruction(ISerializationContext context, Affectation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.AFFECTATION__VAR_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.AFFECTATION__VAR_REF));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.AFFECTATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.AFFECTATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstructionAccess().getVarRefVarRefParserRuleCall_3_1_0(), semanticObject.getVarRef());
		feeder.accept(grammarAccess.getInstructionAccess().getExpressionExpressionParserRuleCall_3_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns If
	 *
	 * Constraint:
	 *     (condition=Expression then=Instruction else=Instruction?)
	 */
	protected void sequence_Instruction(ISerializationContext context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns InstructionBlock
	 *
	 * Constraint:
	 *     instructions+=Instruction+
	 */
	protected void sequence_Instruction(ISerializationContext context, InstructionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Loop
	 *
	 * Constraint:
	 *     (iterator=SpaceIterator body=Instruction)
	 */
	protected void sequence_Instruction(ISerializationContext context, Loop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.LOOP__ITERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.LOOP__ITERATOR));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.LOOP__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstructionAccess().getIteratorSpaceIteratorParserRuleCall_4_2_0(), semanticObject.getIterator());
		feeder.accept(grammarAccess.getInstructionAccess().getBodyInstructionParserRuleCall_4_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ItemArgType returns ItemArgType
	 *
	 * Constraint:
	 *     ((multiple?='{' type=ItemType) | type=ItemType)
	 */
	protected void sequence_ItemArgType(ISerializationContext context, ItemArgType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Job returns InstructionJob
	 *
	 * Constraint:
	 *     (name=ID instruction=Instruction)
	 */
	protected void sequence_Job(ISerializationContext context, InstructionJob semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.JOB__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.JOB__NAME));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.INSTRUCTION_JOB__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.INSTRUCTION_JOB__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJobAccess().getNameIDTerminalRuleCall_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getJobAccess().getInstructionInstructionParserRuleCall_0_3_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Job returns TimeLoopJob
	 *
	 * Constraint:
	 *     (name=ID iterator=TimeIterator initialization=Instruction body=Instruction)
	 */
	protected void sequence_Job(ISerializationContext context, TimeLoopJob semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.JOB__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.JOB__NAME));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.TIME_LOOP_JOB__ITERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.TIME_LOOP_JOB__ITERATOR));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.TIME_LOOP_JOB__INITIALIZATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.TIME_LOOP_JOB__INITIALIZATION));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.TIME_LOOP_JOB__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.TIME_LOOP_JOB__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJobAccess().getNameIDTerminalRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getJobAccess().getIteratorTimeIteratorParserRuleCall_1_4_0(), semanticObject.getIterator());
		feeder.accept(grammarAccess.getJobAccess().getInitializationInstructionParserRuleCall_1_6_0(), semanticObject.getInitialization());
		feeder.accept(grammarAccess.getJobAccess().getBodyInstructionParserRuleCall_1_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulOrDiv
	 *     Or returns MulOrDiv
	 *     Or.Or_1_0 returns MulOrDiv
	 *     And returns MulOrDiv
	 *     And.And_1_0 returns MulOrDiv
	 *     Equality returns MulOrDiv
	 *     Equality.Equality_1_0 returns MulOrDiv
	 *     Comparison returns MulOrDiv
	 *     Comparison.Comparison_1_0 returns MulOrDiv
	 *     PlusOrMinus returns MulOrDiv
	 *     PlusOrMinus.Plus_1_0_0_0 returns MulOrDiv
	 *     PlusOrMinus.Minus_1_0_1_0 returns MulOrDiv
	 *     MulOrDiv returns MulOrDiv
	 *     MulOrDiv.MulOrDiv_1_0 returns MulOrDiv
	 *
	 * Constraint:
	 *     (left=MulOrDiv_MulOrDiv_1_0 (op='*' | op='/') right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, MulOrDiv semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NablaModule returns NablaModule
	 *
	 * Constraint:
	 *     (name=QualifiedName imports+=Import* blocks+=DeclarationBlock* (variables+=ScalarVarDefinition | variables+=VarGroupDeclaration)* jobs+=Job*)
	 */
	protected void sequence_NablaModule(ISerializationContext context, NablaModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 op='||' right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.OR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.OR__OP));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getOpVerticalLineVerticalLineKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 op='-' right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.MINUS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.MINUS__OP));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getOpHyphenMinusKeyword_1_0_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 op='+' right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.PLUS__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.PLUS__OP));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getOpPlusSignKeyword_1_0_0_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.MulOrDiv_1_0 returns Not
	 *     Primary returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Parenthesis
	 *     Or returns Parenthesis
	 *     Or.Or_1_0 returns Parenthesis
	 *     And returns Parenthesis
	 *     And.And_1_0 returns Parenthesis
	 *     Equality returns Parenthesis
	 *     Equality.Equality_1_0 returns Parenthesis
	 *     Comparison returns Parenthesis
	 *     Comparison.Comparison_1_0 returns Parenthesis
	 *     PlusOrMinus returns Parenthesis
	 *     PlusOrMinus.Plus_1_0_0_0 returns Parenthesis
	 *     PlusOrMinus.Minus_1_0_1_0 returns Parenthesis
	 *     MulOrDiv returns Parenthesis
	 *     MulOrDiv.MulOrDiv_1_0 returns Parenthesis
	 *     Primary returns Parenthesis
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Primary(ISerializationContext context, Parenthesis semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.PARENTHESIS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.PARENTHESIS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryMinus
	 *     Or returns UnaryMinus
	 *     Or.Or_1_0 returns UnaryMinus
	 *     And returns UnaryMinus
	 *     And.And_1_0 returns UnaryMinus
	 *     Equality returns UnaryMinus
	 *     Equality.Equality_1_0 returns UnaryMinus
	 *     Comparison returns UnaryMinus
	 *     Comparison.Comparison_1_0 returns UnaryMinus
	 *     PlusOrMinus returns UnaryMinus
	 *     PlusOrMinus.Plus_1_0_0_0 returns UnaryMinus
	 *     PlusOrMinus.Minus_1_0_1_0 returns UnaryMinus
	 *     MulOrDiv returns UnaryMinus
	 *     MulOrDiv.MulOrDiv_1_0 returns UnaryMinus
	 *     Primary returns UnaryMinus
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, UnaryMinus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.UNARY_MINUS__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.UNARY_MINUS__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Real2Constant
	 *     Or returns Real2Constant
	 *     Or.Or_1_0 returns Real2Constant
	 *     And returns Real2Constant
	 *     And.And_1_0 returns Real2Constant
	 *     Equality returns Real2Constant
	 *     Equality.Equality_1_0 returns Real2Constant
	 *     Comparison returns Real2Constant
	 *     Comparison.Comparison_1_0 returns Real2Constant
	 *     PlusOrMinus returns Real2Constant
	 *     PlusOrMinus.Plus_1_0_0_0 returns Real2Constant
	 *     PlusOrMinus.Minus_1_0_1_0 returns Real2Constant
	 *     MulOrDiv returns Real2Constant
	 *     MulOrDiv.MulOrDiv_1_0 returns Real2Constant
	 *     Primary returns Real2Constant
	 *     Atomic returns Real2Constant
	 *     Real2Constant returns Real2Constant
	 *
	 * Constraint:
	 *     (x=REAL y=REAL)
	 */
	protected void sequence_Real2Constant(ISerializationContext context, Real2Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL2_CONSTANT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL2_CONSTANT__X));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL2_CONSTANT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL2_CONSTANT__Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReal2ConstantAccess().getXREALTerminalRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getReal2ConstantAccess().getYREALTerminalRuleCall_3_0(), semanticObject.getY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Real3Constant
	 *     Or returns Real3Constant
	 *     Or.Or_1_0 returns Real3Constant
	 *     And returns Real3Constant
	 *     And.And_1_0 returns Real3Constant
	 *     Equality returns Real3Constant
	 *     Equality.Equality_1_0 returns Real3Constant
	 *     Comparison returns Real3Constant
	 *     Comparison.Comparison_1_0 returns Real3Constant
	 *     PlusOrMinus returns Real3Constant
	 *     PlusOrMinus.Plus_1_0_0_0 returns Real3Constant
	 *     PlusOrMinus.Minus_1_0_1_0 returns Real3Constant
	 *     MulOrDiv returns Real3Constant
	 *     MulOrDiv.MulOrDiv_1_0 returns Real3Constant
	 *     Primary returns Real3Constant
	 *     Atomic returns Real3Constant
	 *     Real3Constant returns Real3Constant
	 *
	 * Constraint:
	 *     (x=REAL y=REAL z=REAL)
	 */
	protected void sequence_Real3Constant(ISerializationContext context, Real3Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL3_CONSTANT__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL3_CONSTANT__X));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL3_CONSTANT__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL3_CONSTANT__Y));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REAL3_CONSTANT__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REAL3_CONSTANT__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReal3ConstantAccess().getXREALTerminalRuleCall_1_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getReal3ConstantAccess().getYREALTerminalRuleCall_3_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getReal3ConstantAccess().getZREALTerminalRuleCall_5_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReductionArg returns ReductionArg
	 *
	 * Constraint:
	 *     (seed=Expression collectionType=BasicType returnType=BasicType)
	 */
	protected void sequence_ReductionArg(ISerializationContext context, ReductionArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REDUCTION_ARG__SEED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REDUCTION_ARG__SEED));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REDUCTION_ARG__COLLECTION_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REDUCTION_ARG__COLLECTION_TYPE));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.REDUCTION_ARG__RETURN_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.REDUCTION_ARG__RETURN_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReductionArgAccess().getSeedExpressionParserRuleCall_1_0(), semanticObject.getSeed());
		feeder.accept(grammarAccess.getReductionArgAccess().getCollectionTypeBasicTypeEnumRuleCall_3_0(), semanticObject.getCollectionType());
		feeder.accept(grammarAccess.getReductionArgAccess().getReturnTypeBasicTypeEnumRuleCall_6_0(), semanticObject.getReturnType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Reduction returns Reduction
	 *
	 * Constraint:
	 *     (name=ID argGroups+=ReductionArg argGroups+=ReductionArg*)
	 */
	protected void sequence_Reduction(ISerializationContext context, Reduction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns ScalarVarDefinition
	 *     ScalarVarDefinition returns ScalarVarDefinition
	 *
	 * Constraint:
	 *     (const?='const'? type=BasicType variable=ScalarVar defaultValue=Expression)
	 */
	protected void sequence_ScalarVarDefinition(ISerializationContext context, ScalarVarDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Var returns ScalarVar
	 *     ScalarVar returns ScalarVar
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ScalarVar(ISerializationContext context, ScalarVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.VAR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScalarVarAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpaceIteratorRange returns SpaceIteratorRange
	 *     IteratorRangeOrRef returns SpaceIteratorRange
	 *
	 * Constraint:
	 *     (connectivity=[Connectivity|ID] (args+=SpaceIteratorRef args+=SpaceIteratorRef*)?)
	 */
	protected void sequence_SpaceIteratorRange(ISerializationContext context, SpaceIteratorRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpaceIteratorRef returns SpaceIteratorRef
	 *     IteratorRangeOrRef returns SpaceIteratorRef
	 *
	 * Constraint:
	 *     (((prev?='◄' | next?='►') iterator=[SpaceIterator|ID]) | iterator=[SpaceIterator|ID])
	 */
	protected void sequence_SpaceIteratorRef(ISerializationContext context, SpaceIteratorRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpaceIterator returns SpaceIterator
	 *
	 * Constraint:
	 *     (name=ID range=SpaceIteratorRange)
	 */
	protected void sequence_SpaceIterator(ISerializationContext context, SpaceIterator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.SPACE_ITERATOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.SPACE_ITERATOR__NAME));
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.SPACE_ITERATOR__RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.SPACE_ITERATOR__RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpaceIteratorAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSpaceIteratorAccess().getRangeSpaceIteratorRangeParserRuleCall_2_0(), semanticObject.getRange());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeIteratorRef returns TimeIteratorRef
	 *
	 * Constraint:
	 *     (iterator=[TimeIterator|ID] ((init?='=' | next?='+') value=INT)?)
	 */
	protected void sequence_TimeIteratorRef(ISerializationContext context, TimeIteratorRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeIterator returns TimeIterator
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_TimeIterator(ISerializationContext context, TimeIterator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NablaPackage.Literals.TIME_ITERATOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NablaPackage.Literals.TIME_ITERATOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeIteratorAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns VarGroupDeclaration
	 *     VarGroupDeclaration returns VarGroupDeclaration
	 *
	 * Constraint:
	 *     (type=BasicType variables+=Var variables+=Var*)
	 */
	protected void sequence_VarGroupDeclaration(ISerializationContext context, VarGroupDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VarRef
	 *     Or returns VarRef
	 *     Or.Or_1_0 returns VarRef
	 *     And returns VarRef
	 *     And.And_1_0 returns VarRef
	 *     Equality returns VarRef
	 *     Equality.Equality_1_0 returns VarRef
	 *     Comparison returns VarRef
	 *     Comparison.Comparison_1_0 returns VarRef
	 *     PlusOrMinus returns VarRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns VarRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns VarRef
	 *     MulOrDiv returns VarRef
	 *     MulOrDiv.MulOrDiv_1_0 returns VarRef
	 *     Primary returns VarRef
	 *     Atomic returns VarRef
	 *     VarRef returns VarRef
	 *
	 * Constraint:
	 *     (variable=[Var|ID] (spaceIterators+=IteratorRangeOrRef spaceIterators+=IteratorRangeOrRef*)? timeIterator=TimeIteratorRef? fields+=ID*)
	 */
	protected void sequence_VarRef(ISerializationContext context, VarRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
